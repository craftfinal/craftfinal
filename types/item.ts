// @/types/item.ts
import { IdSchemaType } from "@/schemas/id";
import { ItemOutputType } from "@/schemas/item";

// The type used for ids generated by the client
export type ClientIdType = IdSchemaType;

export enum ItemDisposition {
  New = "NEW",
  Modified = "MODIFIED",
  Synced = "SYNCED",
}

export type ItemType = ItemOutputType;

// Type used when client sends items to server for merge
// Since `id` and `parentId` both refer to server-generated identifiers, the client
// must be able to operate without them.
// So when creating new items, or even descendants of new items, it will assign
//
export type ItemClientToServerType = Omit<ItemOutputType, "id" | "parentId"> & {
  id?: IdSchemaType;
  parentId?: IdSchemaType;
  disposition: ItemDisposition;
};

// Type returned by server in response to items received from client to merge with server's state
export type ItemServerToClientType = ItemOutputType;

// Type used by client to maintain client state
export type ItemClientStateType = ItemClientToServerType & {
  clientId: IdSchemaType;
  parentClientId: IdSchemaType;
};

export type ItemClientStateOrderableType = ItemClientStateType & {
  order: number;
};

// Type used by server to maintain server state
// This is the full-fledged Prisma schema, inferred by Zod
export type ItemServerStateType = ItemOutputType;

// An object with fields that are specific to the item, i.e., excluding all the fields shared
// between `Resume`, `Organization`, `Role` and `Achievement`
export type ItemDataType<T extends ItemClientStateType> = Omit<T, keyof ItemClientStateType>;
export type ItemDataFieldNameType<T extends ItemClientStateType> = keyof ItemDataType<T>;

// FIXME: The following two types don't add much type safety but
// are currently used to be able to work with components without a type parameter
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type ItemDataUntypedType = Omit<Record<string, any>, keyof ItemClientStateType>;
export type ItemDataUntypedFieldNameType = keyof ItemDataUntypedType;
